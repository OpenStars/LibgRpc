// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: src/proto/grpc/testing/services.proto
// Original file comments:
// Copyright 2015, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// An integration test service that covers all the method signature permutations
// of unary/streaming requests/responses.
#ifndef GRPC_src_2fproto_2fgrpc_2ftesting_2fservices_2eproto__INCLUDED
#define GRPC_src_2fproto_2fgrpc_2ftesting_2fservices_2eproto__INCLUDED

#include "src/proto/grpc/testing/services.pb.h"

#include <grpc++/impl/codegen/async_stream.h>
#include <grpc++/impl/codegen/async_unary_call.h>
#include <grpc++/impl/codegen/method_handler_impl.h>
#include <grpc++/impl/codegen/proto_utils.h>
#include <grpc++/impl/codegen/rpc_method.h>
#include <grpc++/impl/codegen/service_type.h>
#include <grpc++/impl/codegen/status.h>
#include <grpc++/impl/codegen/stub_options.h>
#include <grpc++/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class RpcService;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace grpc {
namespace testing {

class BenchmarkService final {
 public:
  static constexpr char const* service_full_name() {
    return "grpc.testing.BenchmarkService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // One request followed by one response.
    // The server returns the client payload as-is.
    virtual ::grpc::Status UnaryCall(::grpc::ClientContext* context, const ::grpc::testing::SimpleRequest& request, ::grpc::testing::SimpleResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpc::testing::SimpleResponse>> AsyncUnaryCall(::grpc::ClientContext* context, const ::grpc::testing::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpc::testing::SimpleResponse>>(AsyncUnaryCallRaw(context, request, cq));
    }
    // Repeated sequence of one request followed by one response.
    // Should be called streaming ping-pong
    // The server returns the client payload as-is on each response
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>> StreamingCall(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>>(StreamingCallRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>> AsyncStreamingCall(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>>(AsyncStreamingCallRaw(context, cq, tag));
    }
    // Single-sided unbounded streaming from client to server
    // The server returns the client payload as-is once the client does WritesDone
    std::unique_ptr< ::grpc::ClientWriterInterface< ::grpc::testing::SimpleRequest>> StreamingFromClient(::grpc::ClientContext* context, ::grpc::testing::SimpleResponse* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::grpc::testing::SimpleRequest>>(StreamingFromClientRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::grpc::testing::SimpleRequest>> AsyncStreamingFromClient(::grpc::ClientContext* context, ::grpc::testing::SimpleResponse* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::grpc::testing::SimpleRequest>>(AsyncStreamingFromClientRaw(context, response, cq, tag));
    }
    // Single-sided unbounded streaming from server to client
    // The server repeatedly returns the client payload as-is
    std::unique_ptr< ::grpc::ClientReaderInterface< ::grpc::testing::SimpleResponse>> StreamingFromServer(::grpc::ClientContext* context, const ::grpc::testing::SimpleRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::grpc::testing::SimpleResponse>>(StreamingFromServerRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::grpc::testing::SimpleResponse>> AsyncStreamingFromServer(::grpc::ClientContext* context, const ::grpc::testing::SimpleRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::grpc::testing::SimpleResponse>>(AsyncStreamingFromServerRaw(context, request, cq, tag));
    }
    // Two-sided unbounded streaming between server to client
    // Both sides send the content of their own choice to the other
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>> StreamingBothWays(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>>(StreamingBothWaysRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>> AsyncStreamingBothWays(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>>(AsyncStreamingBothWaysRaw(context, cq, tag));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpc::testing::SimpleResponse>* AsyncUnaryCallRaw(::grpc::ClientContext* context, const ::grpc::testing::SimpleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>* StreamingCallRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>* AsyncStreamingCallRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientWriterInterface< ::grpc::testing::SimpleRequest>* StreamingFromClientRaw(::grpc::ClientContext* context, ::grpc::testing::SimpleResponse* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::grpc::testing::SimpleRequest>* AsyncStreamingFromClientRaw(::grpc::ClientContext* context, ::grpc::testing::SimpleResponse* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientReaderInterface< ::grpc::testing::SimpleResponse>* StreamingFromServerRaw(::grpc::ClientContext* context, const ::grpc::testing::SimpleRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::grpc::testing::SimpleResponse>* AsyncStreamingFromServerRaw(::grpc::ClientContext* context, const ::grpc::testing::SimpleRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>* StreamingBothWaysRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>* AsyncStreamingBothWaysRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status UnaryCall(::grpc::ClientContext* context, const ::grpc::testing::SimpleRequest& request, ::grpc::testing::SimpleResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpc::testing::SimpleResponse>> AsyncUnaryCall(::grpc::ClientContext* context, const ::grpc::testing::SimpleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpc::testing::SimpleResponse>>(AsyncUnaryCallRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>> StreamingCall(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>>(StreamingCallRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>> AsyncStreamingCall(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>>(AsyncStreamingCallRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::grpc::testing::SimpleRequest>> StreamingFromClient(::grpc::ClientContext* context, ::grpc::testing::SimpleResponse* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::grpc::testing::SimpleRequest>>(StreamingFromClientRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::grpc::testing::SimpleRequest>> AsyncStreamingFromClient(::grpc::ClientContext* context, ::grpc::testing::SimpleResponse* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::grpc::testing::SimpleRequest>>(AsyncStreamingFromClientRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientReader< ::grpc::testing::SimpleResponse>> StreamingFromServer(::grpc::ClientContext* context, const ::grpc::testing::SimpleRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::grpc::testing::SimpleResponse>>(StreamingFromServerRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::grpc::testing::SimpleResponse>> AsyncStreamingFromServer(::grpc::ClientContext* context, const ::grpc::testing::SimpleRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::grpc::testing::SimpleResponse>>(AsyncStreamingFromServerRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>> StreamingBothWays(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>>(StreamingBothWaysRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>> AsyncStreamingBothWays(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>>(AsyncStreamingBothWaysRaw(context, cq, tag));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::grpc::testing::SimpleResponse>* AsyncUnaryCallRaw(::grpc::ClientContext* context, const ::grpc::testing::SimpleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>* StreamingCallRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>* AsyncStreamingCallRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientWriter< ::grpc::testing::SimpleRequest>* StreamingFromClientRaw(::grpc::ClientContext* context, ::grpc::testing::SimpleResponse* response) override;
    ::grpc::ClientAsyncWriter< ::grpc::testing::SimpleRequest>* AsyncStreamingFromClientRaw(::grpc::ClientContext* context, ::grpc::testing::SimpleResponse* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientReader< ::grpc::testing::SimpleResponse>* StreamingFromServerRaw(::grpc::ClientContext* context, const ::grpc::testing::SimpleRequest& request) override;
    ::grpc::ClientAsyncReader< ::grpc::testing::SimpleResponse>* AsyncStreamingFromServerRaw(::grpc::ClientContext* context, const ::grpc::testing::SimpleRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientReaderWriter< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>* StreamingBothWaysRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>* AsyncStreamingBothWaysRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    const ::grpc::RpcMethod rpcmethod_UnaryCall_;
    const ::grpc::RpcMethod rpcmethod_StreamingCall_;
    const ::grpc::RpcMethod rpcmethod_StreamingFromClient_;
    const ::grpc::RpcMethod rpcmethod_StreamingFromServer_;
    const ::grpc::RpcMethod rpcmethod_StreamingBothWays_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // One request followed by one response.
    // The server returns the client payload as-is.
    virtual ::grpc::Status UnaryCall(::grpc::ServerContext* context, const ::grpc::testing::SimpleRequest* request, ::grpc::testing::SimpleResponse* response);
    // Repeated sequence of one request followed by one response.
    // Should be called streaming ping-pong
    // The server returns the client payload as-is on each response
    virtual ::grpc::Status StreamingCall(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::grpc::testing::SimpleResponse, ::grpc::testing::SimpleRequest>* stream);
    // Single-sided unbounded streaming from client to server
    // The server returns the client payload as-is once the client does WritesDone
    virtual ::grpc::Status StreamingFromClient(::grpc::ServerContext* context, ::grpc::ServerReader< ::grpc::testing::SimpleRequest>* reader, ::grpc::testing::SimpleResponse* response);
    // Single-sided unbounded streaming from server to client
    // The server repeatedly returns the client payload as-is
    virtual ::grpc::Status StreamingFromServer(::grpc::ServerContext* context, const ::grpc::testing::SimpleRequest* request, ::grpc::ServerWriter< ::grpc::testing::SimpleResponse>* writer);
    // Two-sided unbounded streaming between server to client
    // Both sides send the content of their own choice to the other
    virtual ::grpc::Status StreamingBothWays(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::grpc::testing::SimpleResponse, ::grpc::testing::SimpleRequest>* stream);
  };
  template <class BaseClass>
  class WithAsyncMethod_UnaryCall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_UnaryCall() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_UnaryCall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnaryCall(::grpc::ServerContext* context, const ::grpc::testing::SimpleRequest* request, ::grpc::testing::SimpleResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnaryCall(::grpc::ServerContext* context, ::grpc::testing::SimpleRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpc::testing::SimpleResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamingCall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StreamingCall() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_StreamingCall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamingCall(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::grpc::testing::SimpleResponse, ::grpc::testing::SimpleRequest>* stream) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamingCall(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::testing::SimpleResponse, ::grpc::testing::SimpleRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(1, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamingFromClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StreamingFromClient() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_StreamingFromClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamingFromClient(::grpc::ServerContext* context, ::grpc::ServerReader< ::grpc::testing::SimpleRequest>* reader, ::grpc::testing::SimpleResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamingFromClient(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::testing::SimpleResponse, ::grpc::testing::SimpleRequest>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(2, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamingFromServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StreamingFromServer() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_StreamingFromServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamingFromServer(::grpc::ServerContext* context, const ::grpc::testing::SimpleRequest* request, ::grpc::ServerWriter< ::grpc::testing::SimpleResponse>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamingFromServer(::grpc::ServerContext* context, ::grpc::testing::SimpleRequest* request, ::grpc::ServerAsyncWriter< ::grpc::testing::SimpleResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StreamingBothWays : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_StreamingBothWays() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_StreamingBothWays() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamingBothWays(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::grpc::testing::SimpleResponse, ::grpc::testing::SimpleRequest>* stream) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStreamingBothWays(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::testing::SimpleResponse, ::grpc::testing::SimpleRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(4, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_UnaryCall<WithAsyncMethod_StreamingCall<WithAsyncMethod_StreamingFromClient<WithAsyncMethod_StreamingFromServer<WithAsyncMethod_StreamingBothWays<Service > > > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_UnaryCall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_UnaryCall() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_UnaryCall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnaryCall(::grpc::ServerContext* context, const ::grpc::testing::SimpleRequest* request, ::grpc::testing::SimpleResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamingCall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StreamingCall() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_StreamingCall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamingCall(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::grpc::testing::SimpleResponse, ::grpc::testing::SimpleRequest>* stream) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamingFromClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StreamingFromClient() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_StreamingFromClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamingFromClient(::grpc::ServerContext* context, ::grpc::ServerReader< ::grpc::testing::SimpleRequest>* reader, ::grpc::testing::SimpleResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamingFromServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StreamingFromServer() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_StreamingFromServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamingFromServer(::grpc::ServerContext* context, const ::grpc::testing::SimpleRequest* request, ::grpc::ServerWriter< ::grpc::testing::SimpleResponse>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StreamingBothWays : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_StreamingBothWays() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_StreamingBothWays() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StreamingBothWays(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::grpc::testing::SimpleResponse, ::grpc::testing::SimpleRequest>* stream) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnaryCall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_UnaryCall() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::StreamedUnaryHandler< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>(std::bind(&WithStreamedUnaryMethod_UnaryCall<BaseClass>::StreamedUnaryCall, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UnaryCall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnaryCall(::grpc::ServerContext* context, const ::grpc::testing::SimpleRequest* request, ::grpc::testing::SimpleResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnaryCall(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpc::testing::SimpleRequest,::grpc::testing::SimpleResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_UnaryCall<Service > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_StreamingFromServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_StreamingFromServer() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::SplitServerStreamingHandler< ::grpc::testing::SimpleRequest, ::grpc::testing::SimpleResponse>(std::bind(&WithSplitStreamingMethod_StreamingFromServer<BaseClass>::StreamedStreamingFromServer, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_StreamingFromServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StreamingFromServer(::grpc::ServerContext* context, const ::grpc::testing::SimpleRequest* request, ::grpc::ServerWriter< ::grpc::testing::SimpleResponse>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedStreamingFromServer(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::grpc::testing::SimpleRequest,::grpc::testing::SimpleResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_StreamingFromServer<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_UnaryCall<WithSplitStreamingMethod_StreamingFromServer<Service > > StreamedService;
};

class WorkerService final {
 public:
  static constexpr char const* service_full_name() {
    return "grpc.testing.WorkerService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Start server with specified workload.
    // First request sent specifies the ServerConfig followed by ServerStatus
    // response. After that, a "Mark" can be sent anytime to request the latest
    // stats. Closing the stream will initiate shutdown of the test server
    // and once the shutdown has finished, the OK status is sent to terminate
    // this RPC.
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::grpc::testing::ServerArgs, ::grpc::testing::ServerStatus>> RunServer(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::grpc::testing::ServerArgs, ::grpc::testing::ServerStatus>>(RunServerRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::grpc::testing::ServerArgs, ::grpc::testing::ServerStatus>> AsyncRunServer(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::grpc::testing::ServerArgs, ::grpc::testing::ServerStatus>>(AsyncRunServerRaw(context, cq, tag));
    }
    // Start client with specified workload.
    // First request sent specifies the ClientConfig followed by ClientStatus
    // response. After that, a "Mark" can be sent anytime to request the latest
    // stats. Closing the stream will initiate shutdown of the test client
    // and once the shutdown has finished, the OK status is sent to terminate
    // this RPC.
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::grpc::testing::ClientArgs, ::grpc::testing::ClientStatus>> RunClient(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::grpc::testing::ClientArgs, ::grpc::testing::ClientStatus>>(RunClientRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::grpc::testing::ClientArgs, ::grpc::testing::ClientStatus>> AsyncRunClient(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::grpc::testing::ClientArgs, ::grpc::testing::ClientStatus>>(AsyncRunClientRaw(context, cq, tag));
    }
    // Just return the core count - unary call
    virtual ::grpc::Status CoreCount(::grpc::ClientContext* context, const ::grpc::testing::CoreRequest& request, ::grpc::testing::CoreResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpc::testing::CoreResponse>> AsyncCoreCount(::grpc::ClientContext* context, const ::grpc::testing::CoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpc::testing::CoreResponse>>(AsyncCoreCountRaw(context, request, cq));
    }
    // Quit this worker
    virtual ::grpc::Status QuitWorker(::grpc::ClientContext* context, const ::grpc::testing::Void& request, ::grpc::testing::Void* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpc::testing::Void>> AsyncQuitWorker(::grpc::ClientContext* context, const ::grpc::testing::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpc::testing::Void>>(AsyncQuitWorkerRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientReaderWriterInterface< ::grpc::testing::ServerArgs, ::grpc::testing::ServerStatus>* RunServerRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::grpc::testing::ServerArgs, ::grpc::testing::ServerStatus>* AsyncRunServerRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::grpc::testing::ClientArgs, ::grpc::testing::ClientStatus>* RunClientRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::grpc::testing::ClientArgs, ::grpc::testing::ClientStatus>* AsyncRunClientRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpc::testing::CoreResponse>* AsyncCoreCountRaw(::grpc::ClientContext* context, const ::grpc::testing::CoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpc::testing::Void>* AsyncQuitWorkerRaw(::grpc::ClientContext* context, const ::grpc::testing::Void& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    std::unique_ptr< ::grpc::ClientReaderWriter< ::grpc::testing::ServerArgs, ::grpc::testing::ServerStatus>> RunServer(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::grpc::testing::ServerArgs, ::grpc::testing::ServerStatus>>(RunServerRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::grpc::testing::ServerArgs, ::grpc::testing::ServerStatus>> AsyncRunServer(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::grpc::testing::ServerArgs, ::grpc::testing::ServerStatus>>(AsyncRunServerRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::grpc::testing::ClientArgs, ::grpc::testing::ClientStatus>> RunClient(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::grpc::testing::ClientArgs, ::grpc::testing::ClientStatus>>(RunClientRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::grpc::testing::ClientArgs, ::grpc::testing::ClientStatus>> AsyncRunClient(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::grpc::testing::ClientArgs, ::grpc::testing::ClientStatus>>(AsyncRunClientRaw(context, cq, tag));
    }
    ::grpc::Status CoreCount(::grpc::ClientContext* context, const ::grpc::testing::CoreRequest& request, ::grpc::testing::CoreResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpc::testing::CoreResponse>> AsyncCoreCount(::grpc::ClientContext* context, const ::grpc::testing::CoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpc::testing::CoreResponse>>(AsyncCoreCountRaw(context, request, cq));
    }
    ::grpc::Status QuitWorker(::grpc::ClientContext* context, const ::grpc::testing::Void& request, ::grpc::testing::Void* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpc::testing::Void>> AsyncQuitWorker(::grpc::ClientContext* context, const ::grpc::testing::Void& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpc::testing::Void>>(AsyncQuitWorkerRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientReaderWriter< ::grpc::testing::ServerArgs, ::grpc::testing::ServerStatus>* RunServerRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::grpc::testing::ServerArgs, ::grpc::testing::ServerStatus>* AsyncRunServerRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientReaderWriter< ::grpc::testing::ClientArgs, ::grpc::testing::ClientStatus>* RunClientRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::grpc::testing::ClientArgs, ::grpc::testing::ClientStatus>* AsyncRunClientRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncResponseReader< ::grpc::testing::CoreResponse>* AsyncCoreCountRaw(::grpc::ClientContext* context, const ::grpc::testing::CoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpc::testing::Void>* AsyncQuitWorkerRaw(::grpc::ClientContext* context, const ::grpc::testing::Void& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::RpcMethod rpcmethod_RunServer_;
    const ::grpc::RpcMethod rpcmethod_RunClient_;
    const ::grpc::RpcMethod rpcmethod_CoreCount_;
    const ::grpc::RpcMethod rpcmethod_QuitWorker_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Start server with specified workload.
    // First request sent specifies the ServerConfig followed by ServerStatus
    // response. After that, a "Mark" can be sent anytime to request the latest
    // stats. Closing the stream will initiate shutdown of the test server
    // and once the shutdown has finished, the OK status is sent to terminate
    // this RPC.
    virtual ::grpc::Status RunServer(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::grpc::testing::ServerStatus, ::grpc::testing::ServerArgs>* stream);
    // Start client with specified workload.
    // First request sent specifies the ClientConfig followed by ClientStatus
    // response. After that, a "Mark" can be sent anytime to request the latest
    // stats. Closing the stream will initiate shutdown of the test client
    // and once the shutdown has finished, the OK status is sent to terminate
    // this RPC.
    virtual ::grpc::Status RunClient(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::grpc::testing::ClientStatus, ::grpc::testing::ClientArgs>* stream);
    // Just return the core count - unary call
    virtual ::grpc::Status CoreCount(::grpc::ServerContext* context, const ::grpc::testing::CoreRequest* request, ::grpc::testing::CoreResponse* response);
    // Quit this worker
    virtual ::grpc::Status QuitWorker(::grpc::ServerContext* context, const ::grpc::testing::Void* request, ::grpc::testing::Void* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_RunServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_RunServer() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_RunServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunServer(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::grpc::testing::ServerStatus, ::grpc::testing::ServerArgs>* stream) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunServer(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::testing::ServerStatus, ::grpc::testing::ServerArgs>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(0, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RunClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_RunClient() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_RunClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunClient(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::grpc::testing::ClientStatus, ::grpc::testing::ClientArgs>* stream) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunClient(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::testing::ClientStatus, ::grpc::testing::ClientArgs>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(1, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CoreCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CoreCount() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_CoreCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CoreCount(::grpc::ServerContext* context, const ::grpc::testing::CoreRequest* request, ::grpc::testing::CoreResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCoreCount(::grpc::ServerContext* context, ::grpc::testing::CoreRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpc::testing::CoreResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_QuitWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_QuitWorker() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_QuitWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QuitWorker(::grpc::ServerContext* context, const ::grpc::testing::Void* request, ::grpc::testing::Void* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQuitWorker(::grpc::ServerContext* context, ::grpc::testing::Void* request, ::grpc::ServerAsyncResponseWriter< ::grpc::testing::Void>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_RunServer<WithAsyncMethod_RunClient<WithAsyncMethod_CoreCount<WithAsyncMethod_QuitWorker<Service > > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_RunServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_RunServer() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_RunServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunServer(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::grpc::testing::ServerStatus, ::grpc::testing::ServerArgs>* stream) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RunClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_RunClient() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_RunClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunClient(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::grpc::testing::ClientStatus, ::grpc::testing::ClientArgs>* stream) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CoreCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CoreCount() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_CoreCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CoreCount(::grpc::ServerContext* context, const ::grpc::testing::CoreRequest* request, ::grpc::testing::CoreResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_QuitWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_QuitWorker() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_QuitWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QuitWorker(::grpc::ServerContext* context, const ::grpc::testing::Void* request, ::grpc::testing::Void* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CoreCount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CoreCount() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::StreamedUnaryHandler< ::grpc::testing::CoreRequest, ::grpc::testing::CoreResponse>(std::bind(&WithStreamedUnaryMethod_CoreCount<BaseClass>::StreamedCoreCount, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CoreCount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CoreCount(::grpc::ServerContext* context, const ::grpc::testing::CoreRequest* request, ::grpc::testing::CoreResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCoreCount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpc::testing::CoreRequest,::grpc::testing::CoreResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_QuitWorker : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_QuitWorker() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::StreamedUnaryHandler< ::grpc::testing::Void, ::grpc::testing::Void>(std::bind(&WithStreamedUnaryMethod_QuitWorker<BaseClass>::StreamedQuitWorker, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_QuitWorker() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status QuitWorker(::grpc::ServerContext* context, const ::grpc::testing::Void* request, ::grpc::testing::Void* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedQuitWorker(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpc::testing::Void,::grpc::testing::Void>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CoreCount<WithStreamedUnaryMethod_QuitWorker<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_CoreCount<WithStreamedUnaryMethod_QuitWorker<Service > > StreamedService;
};

class ReportQpsScenarioService final {
 public:
  static constexpr char const* service_full_name() {
    return "grpc.testing.ReportQpsScenarioService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Report results of a QPS test benchmark scenario.
    virtual ::grpc::Status ReportScenario(::grpc::ClientContext* context, const ::grpc::testing::ScenarioResult& request, ::grpc::testing::Void* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpc::testing::Void>> AsyncReportScenario(::grpc::ClientContext* context, const ::grpc::testing::ScenarioResult& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpc::testing::Void>>(AsyncReportScenarioRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpc::testing::Void>* AsyncReportScenarioRaw(::grpc::ClientContext* context, const ::grpc::testing::ScenarioResult& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status ReportScenario(::grpc::ClientContext* context, const ::grpc::testing::ScenarioResult& request, ::grpc::testing::Void* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpc::testing::Void>> AsyncReportScenario(::grpc::ClientContext* context, const ::grpc::testing::ScenarioResult& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpc::testing::Void>>(AsyncReportScenarioRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::grpc::testing::Void>* AsyncReportScenarioRaw(::grpc::ClientContext* context, const ::grpc::testing::ScenarioResult& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::RpcMethod rpcmethod_ReportScenario_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Report results of a QPS test benchmark scenario.
    virtual ::grpc::Status ReportScenario(::grpc::ServerContext* context, const ::grpc::testing::ScenarioResult* request, ::grpc::testing::Void* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ReportScenario : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ReportScenario() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ReportScenario() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReportScenario(::grpc::ServerContext* context, const ::grpc::testing::ScenarioResult* request, ::grpc::testing::Void* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReportScenario(::grpc::ServerContext* context, ::grpc::testing::ScenarioResult* request, ::grpc::ServerAsyncResponseWriter< ::grpc::testing::Void>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ReportScenario<Service > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_ReportScenario : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ReportScenario() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ReportScenario() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReportScenario(::grpc::ServerContext* context, const ::grpc::testing::ScenarioResult* request, ::grpc::testing::Void* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReportScenario : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ReportScenario() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::StreamedUnaryHandler< ::grpc::testing::ScenarioResult, ::grpc::testing::Void>(std::bind(&WithStreamedUnaryMethod_ReportScenario<BaseClass>::StreamedReportScenario, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ReportScenario() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReportScenario(::grpc::ServerContext* context, const ::grpc::testing::ScenarioResult* request, ::grpc::testing::Void* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReportScenario(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpc::testing::ScenarioResult,::grpc::testing::Void>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ReportScenario<Service > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ReportScenario<Service > StreamedService;
};

}  // namespace testing
}  // namespace grpc


#endif  // GRPC_src_2fproto_2fgrpc_2ftesting_2fservices_2eproto__INCLUDED
